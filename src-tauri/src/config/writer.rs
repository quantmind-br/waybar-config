// ============================================================================
// CONFIG WRITER
// ============================================================================

use crate::error::{AppError, Result};
use std::fs;
use std::path::{Path, PathBuf};
use std::time::{SystemTime, UNIX_EPOCH};

/// Create a backup of an existing file before modifying it
/// Returns the path to the backup file
pub fn create_backup(file_path: &str) -> Result<PathBuf> {
    let path = Path::new(file_path);

    // Check if file exists
    if !path.exists() {
        return Err(AppError::NotFound(format!("File not found: {}", file_path)));
    }

    // Generate backup filename with timestamp
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map_err(|e| AppError::Internal(format!("Failed to get timestamp: {}", e)))?
        .as_secs();

    let file_name = path
        .file_name()
        .ok_or_else(|| AppError::Internal("Invalid file path".to_string()))?
        .to_str()
        .ok_or_else(|| AppError::Internal("Invalid UTF-8 in file name".to_string()))?;

    let backup_name = format!("{}.backup.{}", file_name, timestamp);
    let backup_path = path.parent()
        .ok_or_else(|| AppError::Internal("Invalid file path".to_string()))?
        .join(backup_name);

    // Copy file to backup
    fs::copy(path, &backup_path)?;

    Ok(backup_path)
}

/// Write content to a file with automatic backup
pub fn write_config_file(file_path: &str, content: &str) -> Result<()> {
    let path = Path::new(file_path);

    // Create backup if file exists
    if path.exists() {
        let backup_path = create_backup(file_path)?;
        log::info!("Created backup at: {:?}", backup_path);
    }

    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)?;
    }

    // Write new content
    fs::write(path, content)?;

    log::info!("Successfully wrote config to: {}", file_path);
    Ok(())
}

/// Format JSON with proper indentation (2 spaces)
pub fn format_json(value: &serde_json::Value) -> Result<String> {
    serde_json::to_string_pretty(value)
        .map_err(|e| AppError::Internal(format!("Failed to format JSON: {}", e)))
}

/// Add JSONC comments to generated configuration
pub fn add_config_comments(json_str: &str) -> String {
    let header = r#"// ============================================================================
// Waybar Configuration
// Generated by Waybar GUI Config Tool
// https://github.com/Alexays/Waybar/wiki/Configuration
// ============================================================================

"#;

    format!("{}{}", header, json_str)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_create_backup() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.json");
        fs::write(&file_path, "original content").unwrap();

        let backup_path = create_backup(file_path.to_str().unwrap()).unwrap();

        assert!(backup_path.exists());
        let backup_content = fs::read_to_string(backup_path).unwrap();
        assert_eq!(backup_content, "original content");
    }

    #[test]
    fn test_write_config_file() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("config.json");

        // Initial write
        write_config_file(file_path.to_str().unwrap(), "content 1").unwrap();
        assert_eq!(fs::read_to_string(&file_path).unwrap(), "content 1");

        // Write again (should create backup)
        write_config_file(file_path.to_str().unwrap(), "content 2").unwrap();
        assert_eq!(fs::read_to_string(&file_path).unwrap(), "content 2");

        // Check backup exists
        let backup_files: Vec<_> = fs::read_dir(temp_dir.path())
            .unwrap()
            .filter_map(Result::ok)
            .filter(|e| e.file_name().to_str().unwrap().contains("backup"))
            .collect();

        assert_eq!(backup_files.len(), 1);
    }

    #[test]
    fn test_format_json() {
        let value = serde_json::json!({
            "key": "value",
            "nested": {
                "array": [1, 2, 3]
            }
        });

        let formatted = format_json(&value).unwrap();
        assert!(formatted.contains("  "));
        assert!(formatted.contains("\"key\": \"value\""));
    }
}
